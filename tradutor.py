# -*- coding: utf-8 -*-
"""Tradutor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1THsNm8UA7p6MISKLido-8kkD0wPgunC5
"""

# mini_lang_all.py
# Tudo-em-um: Léxico + Parser RD + AST + Árvore ASCII + Semântica (com escopos/sombra, const, arrays)
# + Intérprete + Codegen Python. Imprime a TABELA DE SÍMBOLOS logo após a árvore.
# Comentários suportados no léxico: // linha e /* bloco */.
# Recursos: if/else, "else if", while, do-while, print(...),
# operadores: + - * /, < <=, == !=, || && !, unário - e !, true/false,
# declarações: int/bool, const, arrays int[]/bool[] com new int[n]/new bool[n] e bounds check.

import re
from dataclasses import dataclass, is_dataclass
from typing import Optional, List, Dict, Any, Tuple

# =========================================================
# AST
# =========================================================
@dataclass
class Program:
    block: "Block"

@dataclass
class Block:
    stmts: Optional[object]  # Seq encadeado ou None

@dataclass
class Seq:
    first: Optional[object]
    second: object

@dataclass
class Decl:
    typ: str               # "int" | "bool"
    is_array: bool
    is_const: bool
    id: "Id"
    init: Optional[object] = None  # expr ou NewArray

@dataclass
class Eval:
    expr: object

@dataclass
class Print:
    args: List[object]     # print(expr, expr, ...)

@dataclass
class If:
    cond: object
    then_stmt: object
    else_stmt: Optional[object] = None

@dataclass
class While:
    cond: object
    body: object

@dataclass
class Do:
    body: object
    cond: object

@dataclass
class Assign:
    left: object           # Id | ArrayRef
    right: object

@dataclass
class Rel:
    op: str                # '<' | '≤'
    left: object
    right: object

@dataclass
class Eq:
    op: str                # '==' | '!='
    left: object
    right: object

@dataclass
class Lg:
    op: str                # '||' | '&&'
    left: object
    right: object

@dataclass
class Unary:
    op: str                # '-' | '!'
    expr: object

@dataclass
class Ari:
    op: str                # '+', '-', '*', '/'
    left: object
    right: object

@dataclass
class NewArray:
    base: str              # 'int' | 'bool'
    size: object           # expr (int)

@dataclass
class ArrayRef:
    id: "Id"
    index: object          # expr (int)

@dataclass
class Num:
    value: int

@dataclass
class Bool:
    value: bool

@dataclass
class Id:
    name: str


# =========================================================
# Léxico (scanner) — com comentários
# =========================================================
TOKEN_SPEC = [
    ("WS",           r"[ \t\r\n]+"),
    # ---- comentários (antes de '/' e '*') ----
    ("LINECOMMENT",  r"//[^\n]*"),
    ("BLOCKCOMMENT", r"/\*[\s\S]*?\*/"),  # aceita novas linhas no bloco

    ("ANDAND",       r"&&"),
    ("OROR",         r"\|\|"),
    ("NE",           r"!="),
    ("EQEQ",         r"=="),
    ("LE",           r"<="),
    ("LT",           r"<"),
    ("EQUALS",       r"="),
    ("NOT",          r"!"),
    ("PLUS",         r"\+"),
    ("MINUS",        r"-"),
    ("TIMES",        r"\*"),
    ("DIV",          r"/"),
    ("LBRACE",       r"\{"),
    ("RBRACE",       r"\}"),
    ("LPAREN",       r"\("),
    ("RPAREN",       r"\)"),
    ("LBRACK",       r"\["),
    ("RBRACK",       r"\]"),
    ("SEMI",         r";"),
    ("COMMA",        r","),
    ("NUM",          r"\d+"),
    ("ID",           r"[A-Za-z_][A-Za-z0-9_]*"),
    ("MISMATCH",     r"."),
]
MASTER_RE = re.compile("|".join(f"(?P<{n}>{p})" for n, p in TOKEN_SPEC))
KEYWORDS = {
    "if":"IF", "else":"ELSE", "while":"WHILE", "do":"DO", "print":"PRINT",
    "true":"TRUE", "false":"FALSE",
    "int":"INTKW", "bool":"BOOLKW",
    "const":"CONSTKW", "new":"NEW",
}

@dataclass
class Tok:
    type: str
    value: str
    pos: int

def tokenize(src: str) -> List[Tok]:
    out: List[Tok] = []
    for m in MASTER_RE.finditer(src):
        kind = m.lastgroup
        text = m.group()
        pos  = m.start()

        # ignore espaços e comentários
        if kind in ("WS", "LINECOMMENT", "BLOCKCOMMENT"):
            continue

        if kind == "ID" and text in KEYWORDS:
            out.append(Tok(KEYWORDS[text], text, pos))
        elif kind == "NUM":
            out.append(Tok("NUM", text, pos))
        elif kind == "MISMATCH":
            raise SyntaxError(f"Caractere ilegal '{text}' na posição {pos}")
        else:
            out.append(Tok(kind, text, pos))
    out.append(Tok("EOF", "", len(src)))
    return out


# =========================================================
# Parser RD (precedência fraca→forte):
#   = (dir) < || < && < == != < < <= < + - < * / < unário ! -
# =========================================================
class Parser:
    def __init__(self, tokens: List[Tok]):
        self.toks = tokens
        self.i = 0

    def look(self) -> Tok:
        return self.toks[self.i]

    def accept(self, ttype: str) -> Optional[Tok]:
        if self.look().type == ttype:
            tok = self.look()
            self.i += 1
            return tok
        return None

    def expect(self, ttype: str) -> Tok:
        tok = self.look()
        if tok.type != ttype:
            raise SyntaxError(f"Esperado  {ttype}, encontrado {tok.type} ('{tok.value}') na posição {tok.pos}")
        self.i += 1
        return tok

    # program → block
    def parse_program(self) -> Program:
        blk = self.parse_block()
        self.expect("EOF")
        return Program(blk)

    # block → { stmts }
    def parse_block(self) -> Block:
        self.expect("LBRACE")
        s = self.parse_stmts()
        self.expect("RBRACE")
        return Block(s)

    # stmts → (stmt)* | ε
    def parse_stmts(self):
        seq = None
        while self._starts_stmt():
            st = self.parse_stmt()
            seq = Seq(seq, st)
        return seq

    def _starts_stmt(self) -> bool:
        t = self.look().type
        return t in ("LBRACE","IF","WHILE","DO","PRINT","LPAREN","NUM","ID",
                     "INTKW","BOOLKW","TRUE","FALSE","NOT","MINUS","CONSTKW","NEW")

    def parse_stmt(self):
        t = self.look().type
        if t == "LBRACE":
            return self.parse_block()

        if t in ("INTKW","BOOLKW","CONSTKW"):
            return self.parse_decl()

        if t == "PRINT":
            self.expect("PRINT")
            self.expect("LPAREN")
            args = [self.parse_expr()]
            while self.accept("COMMA"):
                args.append(self.parse_expr())
            self.expect("RPAREN")
            self.expect("SEMI")
            return Print(args)

        if t == "IF":
            self.expect("IF"); self.expect("LPAREN")
            cond = self.parse_expr()
            self.expect("RPAREN")
            then_s = self.parse_stmt()
            if self.accept("ELSE"):
                else_s = self.parse_stmt()  # aceita "else if (...) ..." (açúcar)
                return If(cond, then_s, else_s)
            return If(cond, then_s)

        if t == "WHILE":
            self.expect("WHILE"); self.expect("LPAREN")
            cond = self.parse_expr()
            self.expect("RPAREN")
            body = self.parse_stmt()
            return While(cond, body)

        if t == "DO":
            self.expect("DO")
            body = self.parse_stmt()
            self.expect("WHILE"); self.expect("LPAREN")
            cond = self.parse_expr()
            self.expect("RPAREN"); self.expect("SEMI")
            return Do(body, cond)

        # expr ;
        e = self.parse_expr()
        self.expect("SEMI")
        return Eval(e)

    # decl → ["const"] (int|bool) ("[]")? id ( = expr )? ;
    def parse_decl(self):
        is_const = bool(self.accept("CONSTKW"))
        if self.accept("INTKW"):
            base = "int"
        else:
            self.expect("BOOLKW")
            base = "bool"
        is_array = False
        if self.accept("LBRACK"):
            self.expect("RBRACK"); is_array = True
        name = self.expect("ID").value
        init = None
        if self.accept("EQUALS"):
            init = self.parse_expr()
        self.expect("SEMI")
        return Decl(base, is_array, is_const, Id(name), init)

    # expr → or = expr | or
    def parse_expr(self):
        left = self.parse_or()
        if self.accept("EQUALS"):
            right = self.parse_expr()
            return Assign(left, right)
        return left

    # or → and ( '||' and )*
    def parse_or(self):
        node = self.parse_and()
        while self.accept("OROR"):
            node = Lg("||", node, self.parse_and())
        return node

    # and → eq ( '&&' eq )*
    def parse_and(self):
        node = self.parse_eq()
        while self.accept("ANDAND"):
            node = Lg("&&", node, self.parse_eq())
        return node

    # eq → rel ((==|!=) rel)*
    def parse_eq(self):
        node = self.parse_rel()
        while True:
            if self.accept("EQEQ"):
                node = Eq("==", node, self.parse_rel())
            elif self.accept("NE"):
                node = Eq("!=", node, self.parse_rel())
            else:
                break
        return node

    # rel → ari ((<|<=) ari)*
    def parse_rel(self):
        node = self.parse_ari()
        while True:
            if self.accept("LT"):
                node = Rel("<", node, self.parse_ari())
            elif self.accept("LE"):
                node = Rel("≤", node, self.parse_ari())
            else:
                break
        return node

    # ari → term ((+|-) term)*
    def parse_ari(self):
        node = self.parse_term()
        while True:
            if self.accept("PLUS"):
                node = Ari("+", node, self.parse_term())
            elif self.accept("MINUS"):
                node = Ari("-", node, self.parse_term())
            else:
                break
        return node

    # term → unary ((*|/) unary)*
    def parse_term(self):
        node = self.parse_unary()
        while True:
            if self.accept("TIMES"):
                node = Ari("*", node, self.parse_unary())
            elif self.accept("DIV"):
                node = Ari("/", node, self.parse_unary())
            else:
                break
        return node

    # unary → '!' unary | '-' unary | factor
    def parse_unary(self):
        if self.accept("NOT"):
            return Unary("!", self.parse_unary())
        if self.accept("MINUS"):
            # fold -NUM -> Num(-n) para AST mais limpa
            if self.look().type == "NUM":
                tok = self.look(); self.i += 1
                return Num(-int(tok.value))
            return Unary("-", self.parse_unary())
        return self.parse_factor()

    # factor → (expr) | NUM | TRUE | FALSE | NEW base [expr] | ID | ID[expr]
    def parse_factor(self):
        if self.accept("LPAREN"):
            e = self.parse_expr()
            self.expect("RPAREN")
            return e
        tok = self.look()
        if tok.type == "NUM":
            self.i += 1
            return Num(int(tok.value))
        if tok.type == "TRUE":
            self.i += 1
            return Bool(True)
        if tok.type == "FALSE":
            self.i += 1
            return Bool(False)
        if tok.type == "NEW":
            self.i += 1
            if self.accept("INTKW"): base = "int"
            else:
                self.expect("BOOLKW"); base = "bool"
            self.expect("LBRACK")
            size = self.parse_expr()
            self.expect("RBRACK")
            return NewArray(base, size)
        if tok.type == "ID":
            self.i += 1
            ident = Id(tok.value)
            if self.accept("LBRACK"):
                idx = self.parse_expr()
                self.expect("RBRACK")
                return ArrayRef(ident, idx)
            return ident
        raise SyntaxError(f"Esperado fator, encontrado {tok.type} ('{tok.value}') na posição {tok.pos}")


# =========================================================
# Pretty-print da AST (árvore ASCII)
# =========================================================
def _children_of(node):
    if node is None or not is_dataclass(node):
        return []
    if isinstance(node, Program):  return [("block", node.block)]
    if isinstance(node, Block):    return [("stmts", node.stmts)]
    if isinstance(node, Seq):      return [("first", node.first), ("second", node.second)]
    if isinstance(node, Decl):     return [("type", Id(f"{node.typ}{'[]' if node.is_array else ''}{' const' if node.is_const else ''}")), ("id", node.id), ("init", node.init)]
    if isinstance(node, Eval):     return [("expr", node.expr)]
    if isinstance(node, Print):    return [(f"arg[{i}]", a) for i,a in enumerate(node.args)]
    if isinstance(node, If):
        kids = [("cond", node.cond), ("then", node.then_stmt)]
        if node.else_stmt is not None: kids.append(("else", node.else_stmt))
        return kids
    if isinstance(node, While):    return [("cond", node.cond), ("body", node.body)]
    if isinstance(node, Do):       return [("body", node.body), ("cond", node.cond)]
    if isinstance(node, Assign):   return [("left", node.left), ("right", node.right)]
    if isinstance(node, Rel):      return [(f"left op='{node.op}'", node.left), ("right", node.right)]
    if isinstance(node, Eq):       return [(f"left op='{node.op}'", node.left), ("right", node.right)]
    if isinstance(node, Lg):       return [(f"left op='{node.op}'", node.left), ("right", node.right)]
    if isinstance(node, Unary):    return [("expr", node.expr)]
    if isinstance(node, Ari):      return [(f"left op='{node.op}'", node.left), ("right", node.right)]
    if isinstance(node, NewArray): return [("base", Id(node.base)), ("size", node.size)]
    if isinstance(node, ArrayRef): return [("id", node.id), ("index", node.index)]
    if isinstance(node, Num):      return []
    if isinstance(node, Bool):     return []
    if isinstance(node, Id):       return []
    return []

def _label_of(node):
    if isinstance(node, Program):  return "Program"
    if isinstance(node, Block):    return "Block"
    if isinstance(node, Seq):      return "Seq"
    if isinstance(node, Decl):     return f"Decl({node.typ}{'[]' if node.is_array else ''}{', const' if node.is_const else ''})"
    if isinstance(node, Eval):     return "Eval"
    if isinstance(node, Print):    return "Print"
    if isinstance(node, If):       return "If"
    if isinstance(node, While):    return "While"
    if isinstance(node, Do):       return "Do"
    if isinstance(node, Assign):   return "Assign"
    if isinstance(node, Rel):      return f"Rel(op='{node.op}')"
    if isinstance(node, Eq):       return f"Eq(op='{node.op}')"
    if isinstance(node, Lg):       return f"Lg(op='{node.op}')"
    if isinstance(node, Unary):    return f"Unary(op='{node.op}')"
    if isinstance(node, Ari):      return f"Ari(op='{node.op}')"
    if isinstance(node, NewArray): return "NewArray"
    if isinstance(node, ArrayRef): return "ArrayRef"
    if isinstance(node, Num):      return f"Num({node.value})"
    if isinstance(node, Bool):     return f"Bool({node.value})"
    if isinstance(node, Id):       return f"Id({node.name})"
    return type(node).__name__

def print_ast_ascii(node, *, show_edge_labels=True):
    def rec(n, prefix="", is_last=True, edge_label=None):
        connector = "└── " if is_last else "├── "
        if edge_label and show_edge_labels:
            line = f"{prefix}{connector}[{edge_label}] {_label_of(n)}"
        else:
            line = f"{prefix}{connector}{_label_of(n)}"
        print(line)
        new_prefix = f"{prefix}    " if is_last else f"{prefix}│   "
        kids = _children_of(n)
        for i, (elabel, child) in enumerate(kids):
            last = (i == len(kids) - 1)
            if child is None:
                none_line = f"{new_prefix}{'└── ' if last else '├── '}"
                none_line += f"[{elabel}] None" if show_edge_labels else "None"
                print(none_line)
            else:
                rec(child, new_prefix, last, elabel)

    print(_label_of(node))
    kids = _children_of(node)
    for i, (elabel, child) in enumerate(kids):
        last = (i == len(kids) - 1)
        if child is None:
            print(f"{'└── ' if last else '├── '}[{elabel}] None")
        else:
            rec(child, "", last, elabel)


# =========================================================
# Semântica (tipos/def-use + escopos + const + arrays)
# =========================================================
class SemanticError(Exception):
    pass

INT  = "int"
BOOL = "bool"

@dataclass(frozen=True)
class Sym:
    name: str
    typ: str
    is_array: bool
    is_const: bool
    scope_depth: int

def _type_name(typ, is_array=False):
    return f"{typ}{'[]' if is_array else ''}"

def check_semantics(prog: Program):
    """
    Percorre a AST, valida tipos/uso/escopos e
    retorna um snapshot da TABELA DE SÍMBOLOS (lista de dicts).
    """
    scopes: List[Dict[str, Sym]] = []   # pilha de dicionários (um por escopo)
    defs: set[Sym] = set()              # símbolos definitivamente inicializados
    symtab_snapshot: List[Dict[str, Any]] = []

    def push() -> None:
        scopes.append({})

    def pop() -> None:
        nonlocal defs
        # remove defs do escopo que está saindo
        for s in list(defs):
            if s.scope_depth == len(scopes)-1:
                defs.remove(s)
        scopes.pop()

    def declare(name: str, typ: str, is_array: bool, is_const: bool) -> Sym:
        depth = len(scopes)-1
        if name in scopes[-1]:
            raise SemanticError(f"Redeclaração no mesmo escopo: '{name}'.")
        sym = Sym(name, typ, is_array, is_const, depth)
        scopes[-1][name] = sym
        # snapshot para impressão
        symtab_snapshot.append({
            "name": name,
            "type": typ + ("[]" if is_array else ""),
            "const": is_const,
            "scope_depth": depth
        })
        return sym

    def lookup(name: str) -> Sym:
        for depth in range(len(scopes)-1, -1, -1):
            tab = scopes[depth]
            if name in tab: return tab[name]
        raise SemanticError(f"Variável '{name}' não declarada.")

    def _check_block(node: Block):
        push()
        _check_stmts(node.stmts)
        pop()

    def _check_stmts(node):
        if node is None: return
        if isinstance(node, Seq):
            _check_stmts(node.first)
            _check_stmt(node.second)
        else:
            _check_stmt(node)

    def _check_stmt(node):
        nonlocal defs
        if isinstance(node, Block):
            _check_block(node); return

        if isinstance(node, Decl):
            if not scopes: push()  # garantia (em caso de bloco "nu")
            sym = declare(node.id.name, node.typ, node.is_array, node.is_const)
            if node.is_const and node.init is None:
                raise SemanticError(f"const '{sym.name}' requer inicialização.")
            if node.init is not None:
                t, arr = _infer_expr_type(node.init)
                if sym.is_array:
                    if not isinstance(node.init, NewArray):
                        raise SemanticError(f"Inicialização de array '{sym.name}' deve ser 'new {sym.typ}[...]'.")
                    if t != sym.typ or not arr:
                        raise SemanticError(f"Inicialização incompatível em '{sym.name}'.")
                else:
                    if arr:
                        raise SemanticError(f"Variável escalar '{sym.name}' não pode receber array.")
                    if t != sym.typ:
                        raise SemanticError(f"Tipo de '{sym.name}' é {sym.typ}, não {t}.")
                defs.add(sym)
            return

        if isinstance(node, Print):
            for a in node.args: _infer_expr_type(a)
            return

        if isinstance(node, Eval):
            # PATCH: tratar Eval(Assign(...)) como atribuição para atualizar 'defs'
            expr = node.expr
            if isinstance(expr, Assign):
                if isinstance(expr.left, Id):
                    sym = lookup(expr.left.name)
                    if sym.is_const:
                        raise SemanticError(f"Não é permitido reatribuir const '{sym.name}'.")
                    tR, aR = _infer_expr_type(expr.right)
                    if sym.is_array:
                        if not aR:
                            raise SemanticError(f"Variável array '{sym.name}' só pode receber array (new {sym.typ}[...]).")
                        if tR != sym.typ:
                            raise SemanticError(f"Tipo base incompatível em '{sym.name}': esperado {sym.typ}, obtido {tR}.")
                    else:
                        if aR:
                            raise SemanticError(f"Variável escalar '{sym.name}' não pode receber array.")
                        if tR != sym.typ:
                            raise SemanticError(f"Tipo de '{sym.name}' é {sym.typ}, não {tR}.")
                    defs.add(sym)
                    return
                elif isinstance(expr.left, ArrayRef):
                    sym = lookup(expr.left.id.name)
                    if not sym.is_array:
                        raise SemanticError(f"'{sym.name}' não é array.")
                    ti, ai = _infer_expr_type(expr.left.index)
                    if ai or ti != INT:
                        raise SemanticError("Índice de array deve ser int.")
                    tR, aR = _infer_expr_type(expr.right)
                    if aR:
                        raise SemanticError("Atribuição de elemento não aceita array.")
                    if tR != sym.typ:
                        raise SemanticError(f"Elemento de '{sym.name}' é {sym.typ}, não {tR}.")
                    if sym not in defs:
                        raise SemanticError(f"Uso de array '{sym.name}' antes de inicialização.")
                    return
                else:
                    raise SemanticError("Atribuição requer identificador ou acesso a elemento de array à esquerda.")
            else:
                _infer_expr_type(expr)  # expressão sem atribuição
                return

        if isinstance(node, Assign):
            if isinstance(node.left, Id):
                sym = lookup(node.left.name)
                if sym.is_const:
                    raise SemanticError(f"Não é permitido reatribuir const '{sym.name}'.")
                tR, aR = _infer_expr_type(node.right)
                if sym.is_array:
                    if not aR:
                        raise SemanticError(f"Variável array '{sym.name}' só pode receber array (new {sym.typ}[...]).")
                    if tR != sym.typ:
                        raise SemanticError(f"Tipo base incompatível em '{sym.name}': esperado {sym.typ}, obtido {tR}.")
                else:
                    if aR:
                        raise SemanticError(f"Variável escalar '{sym.name}' não pode receber array.")
                    if tR != sym.typ:
                        raise SemanticError(f"Tipo de '{sym.name}' é {sym.typ}, não {tR}.")
                defs.add(sym)
                return
            elif isinstance(node.left, ArrayRef):
                sym = lookup(node.left.id.name)
                if not sym.is_array:
                    raise SemanticError(f"'{sym.name}' não é array.")
                ti, ai = _infer_expr_type(node.left.index)
                if ai or ti != INT:
                    raise SemanticError("Índice de array deve ser int.")
                tR, aR = _infer_expr_type(node.right)
                if aR:
                    raise SemanticError("Atribuição de elemento não aceita array.")
                if tR != sym.typ:
                    raise SemanticError(f"Elemento de '{sym.name}' é {sym.typ}, não {tR}.")
                if sym not in defs:
                    raise SemanticError(f"Uso de array '{sym.name}' antes de inicialização.")
                return
            else:
                raise SemanticError("Atribuição requer identificador ou acesso a elemento de array à esquerda.")

        if isinstance(node, If):
            ct, ca = _infer_expr_type(node.cond)
            if ca or ct != BOOL:
                raise SemanticError("Condição do if deve ser bool.")
            defs_before = set(defs)
            defs_then = set(defs)
            _check_stmt(node.then_stmt)
            defs_after_then = set(defs)
            defs = set(defs_then)
            if node.else_stmt is not None:
                _check_stmt(node.else_stmt)
                defs_after_else = set(defs)
                defs = (defs_after_then & defs_after_else) | (defs_before & defs_after_then & defs_after_else)
            else:
                defs = defs_before
            return

        if isinstance(node, While):
            ct, ca = _infer_expr_type(node.cond)
            if ca or ct != BOOL:
                raise SemanticError("Condição do while deve ser bool.")
            defs_save = set(defs)
            _check_stmt(node.body)
            defs = defs_save
            return

        if isinstance(node, Do):
            _check_stmt(node.body)
            ct, ca = _infer_expr_type(node.cond)
            if ca or ct != BOOL:
                raise SemanticError("Condição do do-while deve ser bool.")
            return

        if isinstance(node, Program):
            _check_block(node.block); return

        raise SemanticError(f"Stmt não reconhecido: {type(node).__name__}")

    def _infer_expr_type(expr) -> Tuple[str, bool]:
        if isinstance(expr, Num):  return (INT, False)
        if isinstance(expr, Bool): return (BOOL, False)
        if isinstance(expr, Id):
            sym = lookup(expr.name)
            if sym.is_array:
                raise SemanticError(f"Array '{sym.name}' não é valor escalar; use {sym.name}[i].")
            if sym not in defs:
                raise SemanticError(f"Uso de variável '{sym.name}' antes de inicialização.")
            return (sym.typ, False)
        if isinstance(expr, NewArray):
            t, a = _infer_expr_type(expr.size)
            if a or t != INT:
                raise SemanticError("Tamanho do array deve ser int.")
            return (expr.base, True)
        if isinstance(expr, ArrayRef):
            sym = lookup(expr.id.name)
            if not sym.is_array:
                raise SemanticError(f"'{sym.name}' não é array.")
            if sym not in defs:
                raise SemanticError(f"Uso de array '{sym.name}' antes de inicialização.")
            ti, ai = _infer_expr_type(expr.index)
            if ai or ti != INT:
                raise SemanticError("Índice de array deve ser int.")
            return (sym.typ, False)
        if isinstance(expr, Unary):
            t, a = _infer_expr_type(expr.expr)
            if expr.op == "!":
                if a or t != BOOL: raise SemanticError("Operador '!' requer bool.")
                return (BOOL, False)
            if expr.op == "-":
                if a or t != INT:  raise SemanticError("Operador unário '-' requer int.")
                return (INT, False)
            raise SemanticError(f"Unário desconhecido: {expr.op}")
        if isinstance(expr, Ari):
            lt, la = _infer_expr_type(expr.left)
            rt, ra = _infer_expr_type(expr.right)
            if la or ra or lt != INT or rt != INT:
                raise SemanticError(f"Operação aritmética '{expr.op}' requer inteiros escalares.")
            return (INT, False)
        if isinstance(expr, Rel):
            lt, la = _infer_expr_type(expr.left)
            rt, ra = _infer_expr_type(expr.right)
            if la or ra or lt != INT or rt != INT:
                raise SemanticError(f"Operação relacional '{expr.op}' requer inteiros escalares.")
            return (BOOL, False)
        if isinstance(expr, Eq):
            lt, la = _infer_expr_type(expr.left)
            rt, ra = _infer_expr_type(expr.right)
            if la or ra or lt != rt:
                raise SemanticError("Comparação requer operandos escalares do mesmo tipo.")
            return (BOOL, False)
        if isinstance(expr, Lg):
            lt, la = _infer_expr_type(expr.left)
            rt, ra = _infer_expr_type(expr.right)
            if la or ra or lt != BOOL or rt != BOOL:
                raise SemanticError(f"Operador lógico '{expr.op}' requer bool.")
            return (BOOL, False)
        if isinstance(expr, Assign):
            return _infer_expr_type(expr.right)
        raise SemanticError(f"Expressão não reconhecida: {type(expr).__name__}")

    _check_block(prog.block)
    return symtab_snapshot  # snapshot para impressão


# =========================================================
# Impressor da TABELA DE SÍMBOLOS
# =========================================================
def print_symtab(symtab_snapshot: List[Dict[str, Any]]):
    print("=== TABELA DE SÍMBOLOS ===")
    for row in sorted(symtab_snapshot, key=lambda r: (r["scope_depth"], r["name"])):
        cflag = " const" if row["const"] else ""
        print(f"[escopo {row['scope_depth']}] {row['name']} : {row['type']}{cflag}")


# =========================================================
# Intérprete (com escopos, arrays com bounds check)
# =========================================================
class RuntimeErrorLang(Exception):
    pass

def exec_program(node: Program, *, trace: bool=False) -> Dict[str, Any]:
    frames: List[Dict[str, Any]] = [{}]

    def push():
        frames.append({})
        if trace: print(">> push {}")
    def pop():
        frames.pop()
        if trace: print("<< pop {}")

    def declare(name: str, value: Any):
        frames[-1][name] = value

    def get(name: str):
        for d in reversed(frames):
            if name in d: return d[name]
        raise RuntimeErrorLang(f"Variável não encontrada: {name}")

    def setvar(name: str, value: Any):
        for d in reversed(frames):
            if name in d:
                d[name] = value
                return value
        frames[-1][name] = value
        return value

    def eval_expr(e):
        if isinstance(e, Num):  return e.value
        if isinstance(e, Bool): return e.value
        if isinstance(e, Id):   return get(e.name)
        if isinstance(e, NewArray):
            n = eval_expr(e.size)
            if n < 0: raise RuntimeErrorLang("Tamanho de array negativo.")
            base_zero = 0 if e.base == "int" else False
            return [base_zero for _ in range(int(n))]
        if isinstance(e, ArrayRef):
            arr = get(e.id.name)
            idx = eval_expr(e.index)
            if not isinstance(arr, list):
                raise RuntimeErrorLang(f"'{e.id.name}' não é array em tempo de execução.")
            if idx < 0 or idx >= len(arr):
                raise RuntimeErrorLang(f"Índice fora dos limites: {idx}")
            return arr[int(idx)]
        if isinstance(e, Unary):
            v = eval_expr(e.expr)
            if e.op == "!": return not bool(v)
            if e.op == "-": return -int(v)
            raise RuntimeErrorLang(f"Unário desconhecido: {e.op}")
        if isinstance(e, Ari):
            a = eval_expr(e.left); b = eval_expr(e.right)
            if e.op == "+": return int(a) + int(b)
            if e.op == "-": return int(a) - int(b)
            if e.op == "*": return int(a) * int(b)
            if e.op == "/": return int(a) // int(b)
            raise RuntimeErrorLang(f"Aritmético desconhecido: {e.op}")
        if isinstance(e, Rel):
            a = eval_expr(e.left); b = eval_expr(e.right)
            if e.op == "<": return int(a) < int(b)
            if e.op == "≤": return int(a) <= int(b)
            raise RuntimeErrorLang(f"Relacional desconhecido: {e.op}")
        if isinstance(e, Eq):
            a = eval_expr(e.left); b = eval_expr(e.right)
            if e.op == "==": return a == b
            if e.op == "!=": return a != b
            raise RuntimeErrorLang(f"Eq desconhecido: {e.op}")
        if isinstance(e, Lg):
            if e.op == "||":
                left = bool(eval_expr(e.left))
                if left: return True
                return bool(eval_expr(e.right))
            if e.op == "&&":
                left = bool(eval_expr(e.left))
                if not left: return False
                return bool(eval_expr(e.right))
            raise RuntimeErrorLang(f"Lógico desconhecido: {e.op}")
        if isinstance(e, Assign):
            val = eval_expr(e.right)
            if isinstance(e.left, Id):
                return setvar(e.left.name, val)
            elif isinstance(e.left, ArrayRef):
                arr = get(e.left.id.name)
                idx = eval_expr(e.left.index)
                if not isinstance(arr, list):
                    raise RuntimeErrorLang(f"'{e.left.id.name}' não é array em tempo de execução.")
                if idx < 0 or idx >= len(arr):
                    raise RuntimeErrorLang(f"Índice fora dos limites: {idx}")
                arr[int(idx)] = val
                return val
            else:
                raise RuntimeErrorLang("Atribuição inválida (lhs).")
        raise RuntimeErrorLang(f"Expressão não suportada: {type(e).__name__}")

    def exec_stmt(s):
        if isinstance(s, Block):
            push()
            exec_stmts(s.stmts)
            pop()
            return
        if isinstance(s, Seq):
            exec_stmts(s.first); exec_stmt(s.second); return
        if isinstance(s, Decl):
            if s.is_array:
                default = None
            else:
                default = 0 if s.typ == "int" else False
            declare(s.id.name, default)
            if s.init is not None:
                v = eval_expr(s.init)
                setvar(s.id.name, v)
            return
        if isinstance(s, Eval):
            val = eval_expr(s.expr)
            if trace: print(f"eval => {val}")
            return
        if isinstance(s, Print):
            vals = [eval_expr(a) for a in s.args]
            print(*vals)
            if trace: print(f"(printed {vals})")
            return
        if isinstance(s, If):
            cond = bool(eval_expr(s.cond))
            if trace: print(f"if ({cond}) ...")
            if cond:
                exec_stmt(s.then_stmt)
            elif s.else_stmt is not None:
                exec_stmt(s.else_stmt)
            return
        if isinstance(s, While):
            while True:
                cond = bool(eval_expr(s.cond))
                if trace: print(f"while ({cond}) ...")
                if not cond: break
                exec_stmt(s.body)
            return
        if isinstance(s, Do):
            while True:
                if trace: print("do { ... }")
                exec_stmt(s.body)
                cond = bool(eval_expr(s.cond))
                if trace: print(f"while ({cond});")
                if not cond: break
            return
        if isinstance(s, Program):
            exec_stmt(s.block); return
        raise RuntimeErrorLang(f"Stmt não suportado: {type(s).__name__}")

    def exec_stmts(node):
        if node is None: return
        if isinstance(node, Seq):
            exec_stmts(node.first); exec_stmt(node.second)
        else:
            exec_stmt(node)

    if trace: print(">> start Program")
    exec_stmt(node.block)
    if trace: print(">> end Program")
    return frames[0]


# =========================================================
# Geração de código Python (com escopos e arrays)
# =========================================================
def codegen_python(prog: Program) -> str:
    out = []
    out.append("def __ml_run(env=None):")
    out.append("    frames = [env if isinstance(env, dict) else {}]")
    out.append("    def push(): frames.append({})")
    out.append("    def pop(): frames.pop()")
    out.append("    def declare(name, val): frames[-1][name] = val")
    out.append("    def get(name):")
    out.append("        for d in reversed(frames):")
    out.append("            if name in d: return d[name]")
    out.append("        raise NameError(f'Variável não encontrada: {name}')")
    out.append("    def setvar(name, val):")
    out.append("        for d in reversed(frames):")
    out.append("            if name in d: d[name]=val; return val")
    out.append("        frames[-1][name]=val; return val")
    out.extend(_cg_stmt(prog.block, indent="    "))
    out.append("    return frames[0]")
    return "\n".join(out)

def _cg_stmt(node, indent=""):
    out = []
    def emit(line): out.append(f"{indent}{line}")
    if isinstance(node, Program):
        out.extend(_cg_stmt(node.block, indent)); return out
    if isinstance(node, Block):
        emit("push()")
        out.extend(_cg_stmts(node.stmts, indent))
        emit("pop()")
        return out
    if isinstance(node, Seq):
        out.extend(_cg_stmts(node, indent)); return out
    if isinstance(node, Decl):
        default = "None" if node.is_array else ("0" if node.typ=="int" else "False")
        emit(f"declare('{node.id.name}', {default})")
        if node.init is not None:
            emit(f"setvar('{node.id.name}', {_cg_expr(node.init)})")
        return out
    if isinstance(node, Eval):
        emit(f"{_cg_expr(node.expr)}  # eval"); return out
    if isinstance(node, Print):
        args = ", ".join(_cg_expr(a) for a in node.args)
        emit(f"print({args})"); return out
    if isinstance(node, If):
        emit(f"if bool({_cg_expr(node.cond)}):")
        out.extend(_cg_stmt(node.then_stmt, indent + "    "))
        if node.else_stmt is not None:
            emit(f"else:")
            out.extend(_cg_stmt(node.else_stmt, indent + "    "))
        return out
    if isinstance(node, While):
        emit(f"while bool({_cg_expr(node.cond)}):")
        out.extend(_cg_stmt(node.body, indent + "    "))
        return out
    if isinstance(node, Do):
        emit("while True:")
        out.extend(_cg_stmt(node.body, indent + "    "))
        emit(f"    if not bool({_cg_expr(node.cond)}):")
        emit("        break")
        return out
    if isinstance(node, Assign):
        if isinstance(node.left, Id):
            emit(f"setvar('{node.left.name}', {_cg_expr(node.right)})")
        else:
            name = node.left.id.name
            idx  = _cg_expr(node.left.index)
            val  = _cg_expr(node.right)
            emit(f"__arr = get('{name}')")
            emit(f"__idx = int({idx})")
            emit(f"__n = len(__arr)")
            emit(f"assert 0 <= __idx < __n, 'Índice fora dos limites: %r' % (__idx,)")
            emit(f"__arr[__idx] = {val}")
        return out
    raise RuntimeError(f"Stmt desconhecido no codegen: {type(node).__name__}")

def _cg_stmts(node, indent=""):
    out = []
    if node is None: return out
    if isinstance(node, Seq):
        out.extend(_cg_stmts(node.first, indent))
        out.extend(_cg_stmt(node.second, indent))
        return out
    out.extend(_cg_stmt(node, indent))
    return out

def _cg_expr(node):
    if isinstance(node, Num):      return str(node.value)
    if isinstance(node, Bool):     return ("True" if node.value else "False")
    if isinstance(node, Id):       return f"get('{node.name}')"
    if isinstance(node, NewArray):
        zero = "0" if node.base=="int" else "False"
        return f"([{zero}] * int({_cg_expr(node.size)}))"
    if isinstance(node, ArrayRef):
        return f"get('{node.id.name}')[int({_cg_expr(node.index)})]"
    if isinstance(node, Unary):
        if node.op == "!": return f"(not bool({_cg_expr(node.expr)}))"
        if node.op == "-": return f"(-({_cg_expr(node.expr)}))"
        raise RuntimeError("unário desconhecido")
    if isinstance(node, Ari):
        op = "//" if node.op=="/" else node.op
        return f"({_cg_expr(node.left)} {op} {_cg_expr(node.right)})"
    if isinstance(node, Rel):
        op = "<=" if node.op=="≤" else node.op
        return f"({_cg_expr(node.left)} {op} {_cg_expr(node.right)})"
    if isinstance(node, Eq):
        return f"({_cg_expr(node.left)} {node.op} {_cg_expr(node.right)})"
    if isinstance(node, Lg):
        if node.op=="||": return f"(bool({_cg_expr(node.left)}) or bool({_cg_expr(node.right)}))"
        if node.op=="&&": return f"(bool({_cg_expr(node.left)}) and bool({_cg_expr(node.right)}))"
        raise RuntimeError("lógico desconhecido")
    if isinstance(node, Assign):
        if isinstance(node.left, Id):
            return f"setvar('{node.left.name}', {_cg_expr(node.right)})"
        else:
            name = node.left.id.name
            idx  = _cg_expr(node.left.index)
            val  = _cg_expr(node.right)
            return ("(lambda __arr, __idx, __val: "
                    "[__arr.__setitem__(__idx, __val), __val][1])"
                    f"(get('{name}'), int({idx}), {val})")
    raise RuntimeError(f"Expr desconhecida no codegen: {type(node).__name__}")

def exec_generated_python(pycode: str, env: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    ns: Dict[str, Any] = {}
    exec(pycode, ns, ns)
    return ns["__ml_run"](env if env is not None else {})


# =========================================================
# Conveniências
# =========================================================
def parse(src: str) -> Program:
    toks = tokenize(src)
    return Parser(toks).parse_program()

def run(src: str, *, trace: bool=False) -> Dict[str, Any]:
    prog = parse(src)
    check_semantics(prog)        # valida e gera snapshot (ignorado aqui)
    return exec_program(prog, trace=trace)

def compile_to_python(src: str) -> str:
    prog = parse(src)
    check_semantics(prog)
    return codegen_python(prog)


# =========================================================
# Demo
# =========================================================
if __name__ == "__main__":
    src = r"""
    {
      const int N = 5;
      int i;
      int[] a = new int[N];
      bool[] flags;
      flags = new bool[3];

      // init
      i = 0;
      while (i < N) {
        a[i] = i * i;
        i = i + 1;
      }
      print(a[0], a[1], a[2]);   // 0 1 4

      // sombra (shadowing) em bloco interno
      {
        int i = 100;     // esconde o i externo
        print(i);        // 100
      }
      print(i);          // ainda é o i externo: 5

      /* if-else com curto-circuito (comentário em bloco com acentos: é, ç, ã) */
      bool ok = true;
      if (ok && (a[2] <= 5 || a[1] == 0)) {
        print(42);
      } else {
        print(99);
      }

      // do-while executa ao menos uma vez
      int j = 0;
      do j = j + 2; while (j < 3);
      print(j);          // 4

      print(true, false, !false, -42);
    }
    """
    print("=== PARSE + AST ===")
    prog = parse(src)
    print_ast_ascii(prog)

    # >>> imprime a TABELA DE SÍMBOLOS logo após a árvore <<<
    symtab = check_semantics(prog)
    print_symtab(symtab)

    print("\n=== CHECAGEM SEMÂNTICA ===")
    print("OK")  # já checamos ao obter o snapshot

    print("\n=== EXECUÇÃO (INTÉRPRETE) ===")
    env = exec_program(prog, trace=True)
    print("\nGlobal env:", env)

    print("\n=== PYTHON GERADO ===")
    py = codegen_python(prog)
    print(py)
    print("\n=== EXECUÇÃO DO PYTHON GERADO ===")
    env2 = exec_generated_python(py)
    print("Global env (codegen):", env2)